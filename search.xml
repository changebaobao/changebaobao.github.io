<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最小生成树</title>
      <link href="2021/04/20/the-small-tree/"/>
      <url>2021/04/20/the-small-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Kruskal-Prim"><a href="#Kruskal-Prim" class="headerlink" title="Kruskal, Prim"></a>Kruskal, Prim</h2><a id="more"></a><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><pre class=" language-c++"><code class="language-c++">struct node { //存储边及边权    int u, v, dis;} e[M];bool cmp(node x, node y){ //sort的比较函数    return x.dis &lt; y.dis;}int father[N]; //存放每个节点的父亲节点的father数组int findfather(int v){ //查找节点的父亲节点    if (father[v] == v)        return v;    else {        int F = findfather(father[v]);        father[v] = F;        return F;    }}int Kruskal(int n, int m){    int ans = 0, num_edge = 0;    //ans为所求最小生成树的边权之和，num_edge为当前生成树的边数    for (int i = 0; i &lt; n; i++) { //father[]初始化，注意节点的范围（以0 - n为例）        father[i] = i;    }    sort(e, e + m, cmp); //对边的权值按照从小到大排序    for (int i = 0; i &lt; m; i++) {        int fu = findfather(e[i].u);        int fv = findfather(e[i].v);        if (fu != fv) { //如果两个节点的父亲节点不同，则将次边加入最小生成树            ans += e[i].dis; //加上边权            father[fu] = fv;            num_edge++;            if (num_edge == n - 1) //如果最小生成树的边数目达到节点数减一，就退出                break;        }    }    return ans;}</code></pre><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxx = 1100;int e[maxx][maxx], dis[maxx];bool book[maxx];int n, m;void init(){    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; n; j++)            if (i == j)                e[i][j] = 0;            else                e[i][j] = inf;}int prim(int e[][maxx], int n){    int ans = 0;    memset(book, false, sizeof(book));    book[0] = true;    for (int i = 1; i &lt; n; i++)        dis[i] = e[0][i];    for (int i = 1; i &lt; n; i++) {        int minn = inf, u = -1;        for (int j = 0; j &lt; n; j++) {            if (!book[j] && dis[j] &lt; minn) {                minn = dis[j];                u = j;            }        }        if (ans == inf)            return -1;        ans += minn;        book[u] = true;        for (int v = 0; v &lt; n; v++)            if (!book[v])                dis[v] = min(dis[v], e[u][v]);    }    return ans;}int main(){    while (cin &gt;&gt; m &gt;&gt; n) {        init();        for (int i = 0; i &lt; n; i++) {            int a, b, c;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;            if (e[a - 1][b - 1] &gt; c)                e[a - 1][b - 1] = e[b - 1][a - 1] = c;        }        cout &lt;&lt; prim(e, m) &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除有序数组中的重复项</title>
      <link href="2021/04/18/leetcode2021418/"/>
      <url>2021/04/18/leetcode2021418/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针思想"><a href="#双指针思想" class="headerlink" title="双指针思想"></a>双指针思想</h2><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>毕竟这是一道简单题，暴力法是完全可以的，正文开始<h2 id="删除有序数组中的重复项https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array-submissions"><a href="#删除有序数组中的重复项https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array-submissions" class="headerlink" title="删除有序数组中的重复项https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/"></a>删除有序数组中的重复项<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/</a></h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3></li><li>在这个数组中前后比较，用另一个数组记录不重复的项，然后再copy一下就行了<pre class=" language-c++"><code class="language-c++">class Solution {public:  int removeDuplicates(vector&lt;int&gt;& nums)  {      int length = nums.size();      if (length == 0) {          return 0;      }      vector&lt;int&gt; v;      v.push_back(nums[0]);      for (int i = 0; i &lt; length-1; i++) {          if (nums[i]!=nums[i+1]) {              v.push_back(nums[i+1]);          }      }      for (int i = 0; i &lt; v.size(); i++) {          nums[i] = v[i];      }      return v.size();  }};</code></pre><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3></li><li>就是用两个类似于指针的东西在原数组上进行操作，判断对应的项是否重复，再进行指针的加加，还要对项的值进行一下修改，，，</li><li>快指针一直动，遍历整个数组，满指针看情况动，一般决定改动后的数组</li><li>时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</li><li>空间复杂度：O(1)。只需要使用常数的额外空间。<pre class=" language-c++"><code class="language-c++">class Solution {public:  int removeDuplicates(vector&lt;int&gt;& nums)  {      if (nums.size() == 0) {          return 0;      }      //双指针，快指针一直进行变化，满指针看情况      int p = 0, q = 1;      while (q &lt; nums.size()) {          if (nums[p]!=nums[q]) {              nums[p + 1] = nums[q];              p++;          }          q++;      }      return p + 1;  }};</code></pre><h2 id="移除元素https-leetcode-cn-com-problems-remove-element"><a href="#移除元素https-leetcode-cn-com-problems-remove-element" class="headerlink" title="移除元素https://leetcode-cn.com/problems/remove-element/"></a>移除元素<a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></h2><h2 id="双指针（思路略有不同）"><a href="#双指针（思路略有不同）" class="headerlink" title="双指针（思路略有不同）"></a>双指针（思路略有不同）</h2><pre class=" language-c++"><code class="language-c++">class Solution {public:  int removeElement(vector&lt;int&gt;& nums, int val)  {      //因为第一个元素也得进行判断，所以快慢指针初始位置相同      int slowindex = 0;      int fastindex = 0;      while (fastindex &lt; nums.size()) {          if (nums[fastindex] != val) {              nums[slowindex] = nums[fastindex];              slowindex++;          }          fastindex++;      }      return slowindex;  }};</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 未知算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存在重复元素</title>
      <link href="2021/04/17/leetcode2021417/"/>
      <url>2021/04/17/leetcode2021417/</url>
      
        <content type="html"><![CDATA[<h3 id="滑动窗口-有序集合，-，桶（以后再说）"><a href="#滑动窗口-有序集合，-，桶（以后再说）" class="headerlink" title="滑动窗口 + 有序集合， ，桶（以后再说）"></a>滑动窗口 + 有序集合， ，桶（以后再说）</h3><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>本来很简单的一道题，结果首先是int不能用，然后又是超时啊，是我不配了，，，以下均是复制粘贴，，，比我想得要复杂得多的多，，</li><li>但收获总是有的，比如  ：lower_bound，，，INT_MAX ，，，INT_MIN</li></ul><h2 id="存在重复元素IIIhttps-leetcode-cn-com-problems-contains-duplicate-iii"><a href="#存在重复元素IIIhttps-leetcode-cn-com-problems-contains-duplicate-iii" class="headerlink" title="存在重复元素IIIhttps://leetcode-cn.com/problems/contains-duplicate-iii/"></a>存在重复元素III<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>对于序列中每一个元素 x 左侧的至多 k 个元素，如果这 k 个元素中存在一个元素落在区间 [x - t, x + t]中，我们就找到了一对符合条件的元素。</li><li>注意到对于两个相邻的元素，它们各自的左侧的 k 个元素中有 k - 1 个是重合的。于是我们可以使用滑动窗口的思路，维护一个大小为 k 的滑动窗口，每次遍历到元素 x 时，滑动窗口中包含元素 x 前面的最多 k 个元素，我们检查窗口中是否存在元素落在区间 [x - t, x + t]中即可。</li><li>采用有序集合支持添加和删除指定元素，并进行二分查找</li><li>细节还有好多，具体参考<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/">https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/</a><pre class=" language-c++"><code class="language-c++">class Solution {public:  bool containsNearbyAlmostDuplicate(vector&lt;int&gt;& nums, int k, int t)  {      int n = nums.size();      set&lt;int&gt; rec;      for (int i = 0; i &lt; n; i++) {          //有序集合中查找大于等于 x - t 的最小的元素 y          auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);          //如果 y 存在，且 y &lt;= x  + t          if (iter != rec.end() && *iter &lt;= min(nums[i], INT_MAX - t) + t) {              return true;          }          //完成检查后，我们将 x 插入到有序集合中          rec.insert(nums[i]);          //如果有序集合中元素数量超过了 k，我们将有序集合中最早被插入的元素删除即可。          if (i &gt;= k) {              rec.erase(nums[i - k]);          }      }      return false;  }};</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 未知算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子序列</title>
      <link href="2021/04/16/leetcode2021416/"/>
      <url>2021/04/16/leetcode2021416/</url>
      
        <content type="html"><![CDATA[<h3 id="似难非难的dp"><a href="#似难非难的dp" class="headerlink" title="似难非难的dp"></a>似难非难的dp</h3><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>又是动态规划，这次是真的不会了，但是方法不止这一种，，，，不害臊的看了题解然后自己跟着敲了几遍，，，最大的收获就是知道了个“ substr ”，，，</li></ul><h2 id="C-中-string-substr-函数的使用方法"><a href="#C-中-string-substr-函数的使用方法" class="headerlink" title="C++中 string.substr() 函数的使用方法"></a>C++中 string.substr() 函数的使用方法</h2><ul><li>substr函数的形式为s.substr(pos, n)，需要两个参数，第一个是开始位置(默认为0)，第二个是获取子串的长度（默认为 s.size() - pos）。<pre class=" language-c++"><code class="language-c++">string s("12345asdf");　　string a = s.substr(0,5);     //获得字符串s中从第0位开始的长度为5的字符串　　cout &lt;&lt; a &lt;&lt; endl;            //</code></pre><h2 id="最长回文子串https-leetcode-cn-com-problems-longest-palindromic-substring"><a href="#最长回文子串https-leetcode-cn-com-problems-longest-palindromic-substring" class="headerlink" title="最长回文子串https://leetcode-cn.com/problems/longest-palindromic-substring/"></a>最长回文子串<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3></li><li>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串，，，万恶的动态规划思想，，，用 dp[i][j] 表示字符串 s 的第 i 到 j 个字母组成的串是否为回文串.</li><li>状态转移方程 ：dp [i][j] = dp [i + 1][j - 1];</li><li>此外还要考虑初始情况，边界条件（当字串长度为1，2时，要特殊判断）</li><li>重点：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。<pre class=" language-c++"><code class="language-c++">class Solution {public:  string longestPalindrome(string s)  {      int n = s.size();      if (n &lt; 2) {          return s;      }      int maxlen = 1;      int begin = 0;      // 好牛逼的初始化，长见识了      vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));      //初始化已知条件      for (int i = 0; i &lt; n; i++) {          dp[i][i] = true;      }      //枚举字串长度      for (int l = 2; l &lt;= n; l++) {          //枚举左边界          for (int i = 0; i &lt; n; i++) {               //右边界              int j = l + i - 1;              if (j &gt;= n) {                  break;              }              if (s[i] != s[j]) {                  dp[i][j] = false;              } else {                  if (j - i &lt; 3) {                      dp[i][j] = true;                  } else {                      dp[i][j] = dp[i + 1][j - 1];                  }              }              if (dp[i][j] && j - i + 1 &gt; maxlen) {                  maxlen = j - i + 1;                  begin = i;              }          }      }      return s.substr(begin,maxlen);  }};</code></pre></li></ul><h3 id="方法二：中心扩展算法"><a href="#方法二：中心扩展算法" class="headerlink" title="方法二：中心扩展算法"></a>方法二：中心扩展算法</h3><h3 id="方法三：Manacher算法（待补充）-终极题解"><a href="#方法三：Manacher算法（待补充）-终极题解" class="headerlink" title="方法三：Manacher算法（待补充）(终极题解)"></a>方法三：Manacher算法（待补充）(终极题解)</h3>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础dp</title>
      <link href="2021/04/15/leetcode2021415/"/>
      <url>2021/04/15/leetcode2021415/</url>
      
        <content type="html"><![CDATA[<h3 id="基础dp，比硬币问题还简单"><a href="#基础dp，比硬币问题还简单" class="headerlink" title="基础dp，比硬币问题还简单"></a>基础dp，比硬币问题还简单</h3><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本来对动态规划的认知约等于0，今天还正好碰到了，什么子问题，最优解，状态转移方程等等等等，反正就是很烦，不过今天碰到的题似乎算是基础中的基础，正文开始</p><h2 id="基础版https-leetcode-cn-com-problems-house-robber"><a href="#基础版https-leetcode-cn-com-problems-house-robber" class="headerlink" title="基础版https://leetcode-cn.com/problems/house-robber/"></a>基础版<a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></h2><ul><li>每次选择一个房屋后后，它之前的那个就选不了了，但是之前的前面那个还可以选，类推开始：只有一个时，解唯一，两个时，选择较大的那个，三个是，对于其只有两种情况，选或不选，若选了，则还能选第一个，若不选，则为它前一个的解。。。。。状态转移方程得出<pre class=" language-c++"><code class="language-c++">states[i] = max(states[i - 1], states[i - 2] + nums[i]);</code></pre></li><li>总的代码<pre class=" language-c++"><code class="language-c++">class Solution {public:  int rob(vector&lt;int&gt;& nums)  {      int n = nums.size();      if (n == 0)          return 0;      if (n == 1)          return nums[0];      vector&lt;int&gt; states = vector&lt;int&gt;(n, 0);      states[0] = nums[0];      states[1] = max(nums[0], nums[1]);      for (int i = 2; i &lt; n; i++) {          states[i] = max(states[i - 1], states[i - 2] + nums[i]);      }      return states[n - 1];  }};</code></pre></li><li>代码进阶，上面那一种感觉已经很简单了，但是之后又看到题解中还有滚顶数组啥的，咱也不太会，复制粘贴纪念一下（以后一定学会）</li></ul><pre class=" language-c++"><code class="language-c++">class Solution {    public int rob(int[] nums) {        if (nums == null || nums.length == 0) {            return 0;        }        int length = nums.length;        if (length == 1) {            return nums[0];        }        int first = nums[0], second = Math.max(nums[0], nums[1]);        for (int i = 2; i &lt; length; i++) {            int temp = second;            second = Math.max(first + nums[i], second);            first = temp;        }        return second;    }}</code></pre><h2 id="进阶版-lt-https-leetcode-cn-com-problems-house-robber-ii-submissions"><a href="#进阶版-lt-https-leetcode-cn-com-problems-house-robber-ii-submissions" class="headerlink" title="进阶版&lt;https://leetcode-cn.com/problems/house-robber-ii/submissions/"></a>进阶版&lt;<a href="https://leetcode-cn.com/problems/house-robber-ii/submissions/">https://leetcode-cn.com/problems/house-robber-ii/submissions/</a></h2><ul><li><p>进阶版，只不过是需要想的条件多一点而已，第一个选了，最后一个就选不了了，反之。不如直接分为两大组，分别考虑。。。。。。第一次做是直接开了两个状态数组，些许麻烦，直接看官方题解吧(也是用到了滚动数组，嘤嘤嘤)</p><pre class=" language-c++"><code class="language-c++">class Solution {public:  int robRange(vector&lt;int&gt;& nums, int start, int end) {      int first = nums[start], second = max(nums[start], nums[start + 1]);      for (int i = start + 2; i &lt;= end; i++) {          int temp = second;          second = max(first + nums[i], second);          first = temp;      }      return second;  }  int rob(vector&lt;int&gt;& nums) {      int length = nums.size();      if (length == 1) {          return nums[0];      } else if (length == 2) {          return max(nums[0], nums[1]);      }      return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));  }};</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="2021/04/14/Trie/"/>
      <url>2021/04/14/Trie/</url>
      
        <content type="html"><![CDATA[<h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li><p>第一次见到这玩意，没资格多说废话，正文开始</p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2></li><li><p>Trie树，即前缀树，又称单词查找树，字典树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p></li><li><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p></li><li><p>模板题<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><pre class=" language-c++"><code class="language-c++">//prefix 前缀class Trie {private:  vector&lt;Trie*&gt; children;  bool isEnd;  Trie* searchPrefix(string prefix)  {      Trie* node = this;      for (char ch : prefix) {          ch -= 'a';          if (node-&gt;children[ch] == nullptr) {              return nullptr;          }          node = node-&gt;children[ch];      }      return node;  }public:  Trie(): children(26), isEnd(false) { }  void insert(string word)  {      Trie* node = this;      for (char ch : word) {          ch -= 'a';          if (node-&gt;children[ch]==nullptr) {              node-&gt;children[ch] = new Trie();          }          node = node-&gt;children[ch];      }      node-&gt;isEnd = true;  }  //如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。  bool search(string word) {      Trie* node = this-&gt;searchPrefix(word);      return node != nullptr && node-&gt;isEnd;  }  //如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。  bool startsWith(string prefix) {      return this-&gt;searchPrefix(prefix) != nullptr;  }};</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="2021/03/21/the-short-path/"/>
      <url>2021/03/21/the-short-path/</url>
      
        <content type="html"><![CDATA[<h2 id="Floyd，Dijkstra"><a href="#Floyd，Dijkstra" class="headerlink" title="Floyd，Dijkstra"></a>Floyd，Dijkstra</h2><a id="more"></a><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int dis[100][100], n, m, t1, t2, t3;    int inf = 999999;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) {            if (i == j) {                dis[i][j] = 0;            } else {                dis[i][j] = inf;            }        }    }    for (int i = 1; i &lt;= m; i++) {        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;            dis[t2][t1] = t3;            dis[t1][t2] = t3;    }    // 核心代码    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= n; j++) {                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);            }        }    }    cout &lt;&lt; dis[1][n] &lt;&lt; endl;    return 0;}</code></pre><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int e[10][10], dis[10], book[10], n, m, t1, t2, t3, u, min;    int inf = 999999;    //初始化    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= n; j++) {            if (i == j) {                e[i][j] = 0;            } else {                e[i][j] = inf;            }        }    }    for (int i = 1; i &lt;= m; i++) {        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;        e[t1][t2] = t3;    }    for (int i = 1; i &lt;= n; i++) {        dis[i] = e[1][i];    }    for (int i = 1; i &lt;= n; i++) {        book[i] = 0;    }    //核心语句    book[1] = 1;    for (int i = 1; i &lt;= n - 1; i++) {        min = inf;        for (int j = 0; j &lt;= n; j++) {            if (book[j] == 0 && dis[j] &lt; min) {                min = dis[j];                u = j;            }        }        book[u] = 1;        for (int v = 1; v &lt;= n; v++) {            if (e[u][v] &lt; inf) {                dis[v] = min(dis[v], dis[u] + e[u][v]);            }        }    }    for (int i = 1; i &lt;= n; i++) {        cout &lt;&lt; dis[i] &lt;&lt; " ";    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数</title>
      <link href="2021/03/20/Catallan/"/>
      <url>2021/03/20/Catallan/</url>
      
        <content type="html"><![CDATA[<h2 id="Catallan数列"><a href="#Catallan数列" class="headerlink" title="Catallan数列"></a>Catallan数列</h2><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin</a></p><h2 id="以下问题属于-Catalan-数列："><a href="#以下问题属于-Catalan-数列：" class="headerlink" title="以下问题属于 Catalan 数列："></a>以下问题属于 Catalan 数列：</h2><ul><li><p>买票问题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1133">http://acm.hdu.edu.cn/showproblem.php?pid=1133</a></p></li><li><p>对角线不相交的情况下，将一个凸多边形区域分成三角形区域的方法数？</p></li><li><p>在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数？</p></li><li><p>一个栈（无穷大）的进栈序列为1,2,3,…,n有多少个不同的出栈序列？</p></li><li><p>n个结点可构造多少个不同的二叉树？</p></li><li><p>n个不同的数依次进栈，求不同的出栈结果的种数</p><h2 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h2></li><li><p>h(n) = h(n - 1) *（4n - 2）/ (n + 1)</p></li></ul><h2 id="模板题http-acm-hdu-edu-cn-showproblem-php-pid-1130"><a href="#模板题http-acm-hdu-edu-cn-showproblem-php-pid-1130" class="headerlink" title="模板题http://acm.hdu.edu.cn/showproblem.php?pid=1130"></a>模板题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1130">http://acm.hdu.edu.cn/showproblem.php?pid=1130</a></h2><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int LEN = 1005;int num[LEN][LEN];int c[LEN][LEN];void init(){    memset(num, 0, sizeof(num));    num[1][1] = 1;    for (int i = 2; i &lt;= 1001; i++) {        for (int j = 1; j &lt;= 1001; j++) {            num[i][j] += num[i - 1][j] * (4 * i - 2);        }        for (int j = 1; j &lt;= 1001; j++) {            num[i][j + 1] += num[i][j] / 10;            num[i][j] = num[i][j] % 10;        }        for (int j = 1001; j &gt; 0; j--) {            num[i][j - 1] += num[i][j] % (i + 1) * 10;            num[i][j] /= i + 1;        }    }}int main(){    init();    int n;    while (~scanf_s("%d", &n)) {        int end = 1000;        while (num[n][end] == 0) {            end--;        }        while (end &gt; 0) {            putchar('0' + num[n][end--]);        }        cout &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 卡特兰数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bfs</title>
      <link href="2021/03/18/bfs/"/>
      <url>2021/03/18/bfs/</url>
      
        <content type="html"><![CDATA[<h2 id="简简单单的bfs模板"><a href="#简简单单的bfs模板" class="headerlink" title="简简单单的bfs模板"></a>简简单单的bfs模板</h2><a id="more"></a><ul><li><a href="http://poj.org/problem?id=3278">http://poj.org/problem?id=3278</a><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100001;int step[maxn];int vis[maxn];int n, k;queue&lt;int&gt; Q;int bfs(int n, int k){  int p, q;  step[n] = 0;  vis[n] = 1;  Q.push(n);  while (!Q.empty()) {      p = Q.front();      Q.pop();      for (int i = 0; i &lt; 3; i++) {          if (i==0) {              q = p - 1;          } else if (i==1) {              q = p + 1;          } else {              q = p * 2;          }          if (q&lt;0 || q&gt;=maxn) {              continue;          }          if (!vis[q]) {              Q.push(q);              vis[q] = 1;              step[q] = step[p] + 1;          }          if (q==k) {              return step[q];          }      }  }}int main(){  while (cin&gt;&gt;n&gt;&gt;k) {      memset(vis, 0, sizeof(vis));      memset(step, 0, sizeof(step));      while (!Q.empty()) {          Q.pop();      }      if (n&gt;=k) {          cout &lt;&lt; n - k &lt;&lt; endl;      } else {          cout &lt;&lt; bfs(n, k) &lt;&lt; endl;      }  }  return 0;}</code></pre></li><li>模板升级,但还是好简单<a href="https://www.luogu.com.cn/problem/P1135">https://www.luogu.com.cn/problem/P1135</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="2021/03/08/binary-search/"/>
      <url>2021/03/08/binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="简简单单的二分模板"><a href="#简简单单的二分模板" class="headerlink" title="简简单单的二分模板"></a>简简单单的二分模板</h2><a id="more"></a><h2 id="整数二分模板"><a href="#整数二分模板" class="headerlink" title="整数二分模板"></a>整数二分模板</h2><pre class=" language-c++"><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch(int l, int r){    while (l &lt; r) {        int mid = (l + r) &gt;&gt; 1;        if (check(mid))            r = mid; // check()判断mid是否满足性质        else            l = mid + 1;    }    return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch(int l, int r){    while (l &lt; r) {        int mid = (l + r + 1) &gt;&gt; 1;        if (check(mid))            l = mid;        else            r = mid - 1;    }    return l;}</code></pre><h2 id="浮点数二分模板"><a href="#浮点数二分模板" class="headerlink" title="浮点数二分模板"></a>浮点数二分模板</h2><pre class=" language-c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch(double l, double r){    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    {        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    return l;}</code></pre><h2 id="二分题（入门）"><a href="#二分题（入门）" class="headerlink" title="二分题（入门）"></a>二分题（入门）</h2><h3 id="整数二分例题（待补充）"><a href="#整数二分例题（待补充）" class="headerlink" title="整数二分例题（待补充）"></a>整数二分例题（待补充）</h3><p><a href="https://www.luogu.com.cn/problem/P1873">https://www.luogu.com.cn/problem/P1873</a></p><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int a[1000005];int n, m;bool check(int k){ // 检查可行性，k为锯片高度    long long sum = 0;    for (int i = 1; i &lt;= n; i++) // 检查每一棵树        if (a[i] &gt; k) // 如果树高于锯片高度            sum += (long long)(a[i] - k); // 累加树木长度    return sum &gt;= m; // 如果满足最少长度代表可行}int find(){    int l = 1, r = 1000000001; // 因为是左闭右开的，所以10亿要加1    while (l + 1 &lt; r) { // 如果两点不相邻        int mid = (l + r) / 2; // 取中间值        if (check(mid)) // 如果可行            l = mid; // 升高锯片高度        else            r = mid; // 否则降低锯片高度    }    return l; // 返回左边值}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    cout &lt;&lt; find();    return 0;}</code></pre><h3 id="浮点数二分例题（待补充）"><a href="#浮点数二分例题（待补充）" class="headerlink" title="浮点数二分例题（待补充）"></a>浮点数二分例题（待补充）</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2899">http://acm.hdu.edu.cn/showproblem.php?pid=2899</a></p><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define e 1e-7double fac(double a, double b){    return 6 * a * a * a * a * a * a * a + 8 * a * a * a * a * a * a + 7 * a * a * a + 5 * a * a - b * a;}double fac0(double a, double b){    return 42 * a * a * a * a * a * a + 48 * a * a * a * a * a + 21 * a * a + 10 * a - b;}int main(){    int t;    double n;    cin &gt;&gt; t;    while (t--) {        cin&gt;&gt;n;        double l = 0;        double r = 100;        while (r - l &gt; e) {            double mid = (l + r) / 2;            if (fac0(mid, n) &gt; 0)                r = mid;            else                l = mid;        }        printf("%.4lf\n", fac(r, n));    }    return 0;}</code></pre><h2 id="三分模板（待补充）"><a href="#三分模板（待补充）" class="headerlink" title="三分模板（待补充）"></a>三分模板（待补充）</h2><pre class=" language-c++"><code class="language-c++">lmid = left + (right - left &gt;&gt; 1);rmid = lmid + (right - lmid &gt;&gt; 1);  // 对右侧区间取半if (cal(lmid) &gt; cal(rmid))  right = rmid;else  left = lmid;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼编码长度简便求法</title>
      <link href="2021/03/07/hafumanbianmachengdu/"/>
      <url>2021/03/07/hafumanbianmachengdu/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫曼编码长度求法（使用Stl等）"><a href="#哈夫曼编码长度求法（使用Stl等）" class="headerlink" title="哈夫曼编码长度求法（使用Stl等）"></a>哈夫曼编码长度求法（使用Stl等）</h2><a id="more"></a><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1053">http://acm.hdu.edu.cn/showproblem.php?pid=1053</a></li></ul><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt; using namespace std;/*1.获取字符串2.map记录字符与其对应的出现的次数3.按照从小到大的顺序入列priority_queue（优先队列）4.每次出队两个，相加后再次入队，并进行排序5.用ans记录每一次相加和temp值之和，当队列中剩下一个元素时，ans的值即为所求*/string s;int main(){    int ans = 0;    map&lt;char, int&gt; mp;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //升序排列    getline(cin, s);    if (s == "END") {        break;    }    int len = s.length();    for (int i = 0; i &lt; len; i++) { //记录字符与其对应的出现的次数        if (mp.find(s[i]) == mp.end()) {            mp[s[i]] = 1;        } else {            mp[s[i]]++;        }    }    for (map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) {        q.push(it-&gt;second); //字符出现的次数入队    }    while (q.size() != 1) {        int a, b, temp; //a，b记录最小的两个次数        a = q.top();        q.pop();        b = q.top();        q.pop();        temp = a + b; //队列中最小的两个次数相加        ans += temp;        q.push(temp); //最小的两个次数相加再次入队，优先队列自行排序    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="2021/03/04/dp/"/>
      <url>2021/03/04/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="基础的动态规划问题"><a href="#基础的动态规划问题" class="headerlink" title="基础的动态规划问题"></a>基础的动态规划问题</h2><a id="more"></a><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">// w[i] 重量// v[i] 价值  for (int i = 1; i &lt;= n; i++) {     for (int j = m; j &gt;= w[i]; j--) {         f[j] = max(f[j - w[i]] + v[i], f[j]);    }}cout &lt;&lt; f[m] &lt;&lt; endl;</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.luogu.com.cn/problem/P2871">https://www.luogu.com.cn/problem/P2871</a><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int w[3410], v[3410];int f[13000];int main(){  int m, n;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= n; i++) {      cin &gt;&gt; w[i] &gt;&gt; v[i];  }  for (int i = 1; i &lt;= n; i++) {      for (int j = m; j &gt;= w[i]; j--) {          f[j] = max(f[j - w[i]] + v[i], f[j]);      }  }  cout &lt;&lt; f[m] &lt;&lt; endl;  return 0;}</code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2></li><li>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">for (int i = 1; i &lt;= n; i++) {  for (int l = w[i]; l &lt;= W; l++) {      f[l] = max(f[l], f[l - w[i]] + v[i]);  }}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3></li><li><a href="https://www.luogu.com.cn/problem/P1616">https://www.luogu.com.cn/problem/P1616</a><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int maxn = 1e4 + 5;const int maxW = 1e7 + 5;int n, m, w[maxn], v[maxn];long long f[maxW];int main(){cin &gt;&gt; m &gt;&gt; n;for (int i = 1; i &lt;= n; i++) {    cin &gt;&gt; w[i] &gt;&gt; v[i];}for (int i = 1; i &lt;= n; i++) {    for (int l = w[i]; l &lt;= m; l++) {        f[l] = max(f[l], f[l - w[i]] + v[i]);    }}cout &lt;&lt; f[m];return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/03/03/bing-cha-ji/"/>
      <url>2021/03/03/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集基本用法"><a href="#并查集基本用法" class="headerlink" title="并查集基本用法"></a>并查集基本用法</h2><a id="more"></a><h2 id="并查集基础核心代码"><a href="#并查集基础核心代码" class="headerlink" title="并查集基础核心代码"></a>并查集基础核心代码</h2><pre class=" language-c++"><code class="language-c++">int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = t2;    }}</code></pre><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">http://acm.hdu.edu.cn/showproblem.php?pid=1213</a></li></ul><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int p[1010];void init() { for (int i = 0; i &lt; 1010; i++) {        p[i] = i;    }}int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = t2;    }}int main(){    int t;    cin &gt;&gt; t;    int n, m, x, y, ans;    while (t--) {        cin &gt;&gt; n &gt;&gt; m;        init();        for (int i = 0; i &lt; m; i++) {            cin &gt;&gt; x &gt;&gt; y;            Union(x, y);        }        ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (p[i]==i) {                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="类似题型"><a href="#类似题型" class="headerlink" title="类似题型"></a>类似题型</h2><ul><li><a href="http://poj.org/problem?id=2524">http://poj.org/problem?id=2524</a></li><li><a href="http://poj.org/problem?id=1611">http://poj.org/problem?id=1611</a></li><li><a href="http://poj.org/problem?id=1703">http://poj.org/problem?id=1703</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论入门</title>
      <link href="2021/02/11/math/"/>
      <url>2021/02/11/math/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数论（公倍数，公约数，快速幂等"><a href="#基本数论（公倍数，公约数，快速幂等" class="headerlink" title="基本数论（公倍数，公约数，快速幂等"></a>基本数论（公倍数，公约数，快速幂等</h2><a id="more"></a><h2 id="最大公约数–欧几里得算法"><a href="#最大公约数–欧几里得算法" class="headerlink" title="最大公约数–欧几里得算法"></a>最大公约数–欧几里得算法</h2><pre class=" language-C++"><code class="language-C++">int gcd(int a, int b){    return b == 0 ? a : gcd(b, a % b);}</code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><ul><li>gcd(a,b) * lcm(a,b) = a * b;<pre class=" language-C++"><code class="language-C++">int lcm(int a, int b){  return a * b / gcd(a, b);}</code></pre></li></ul><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow(long long a, long long b){    long long ret = 1;    while (b) {        if (b & 1) {            ret *= a;        }        a *= a;        b &gt;&gt;= 1;    }    return ret;}</code></pre><h2 id="快速幂取模-计算a-b-mod-m"><a href="#快速幂取模-计算a-b-mod-m" class="headerlink" title="快速幂取模:计算a^b mod m"></a>快速幂取模:计算a^b mod m</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow_mod(long long a, long long b, long long m){    long long res = 1;    while (b &gt; 0) {        if (b & 1)            res = res * a % m;        a = a * a % m;        b &gt;&gt;= 1;    }    return res;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector(动态数组)</title>
      <link href="2021/02/08/vector/"/>
      <url>2021/02/08/vector/</url>
      
        <content type="html"><![CDATA[<h2 id="c-stl库中vector的基本用法"><a href="#c-stl库中vector的基本用法" class="headerlink" title="c++stl库中vector的基本用法"></a>c++stl库中vector的基本用法</h2><a id="more"></a><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre class=" language-c++"><code class="language-c++">vector&lt;type&gt; v; //后面可以加{},()进行初始化vector&lt;double&gt; v2{1, 2, 3, 6, 5};vector&lt;long long&gt; v3(20);        //长度为20vector&lt;string&gt; v4(20, "abcde");  //长度为20</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-c++"><code class="language-c++">v.push_back(item);  //v后面添加元素itemv.pop_back();       //删除v的最后一个元素v.size();           //返回元素个数v.resize(n);        //把v的长度设为nv.empty();          //判断是否为空，空返回1，不空返回0v.clear();          //清空v中的元素v.front();          //返回首元素的引用v.back();           //返回尾元素的引用v.begin();          //返回首迭代器，指向第一个元素v.end();            //返回尾迭代器，指向最后一个元素的下一个位置   </code></pre><h2 id="vector中使用pair"><a href="#vector中使用pair" class="headerlink" title="vector中使用pair"></a>vector中使用pair</h2><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">http://acm.hdu.edu.cn/showproblem.php?pid=2037</a>（活动安排问题）</p><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){  int n, a, b;  int ans,t;  while (cin&gt;&gt;n && n) {      vector&lt;pair&lt;int, int&gt;&gt; v;      for (int i = 0; i &lt; n; i++) {          cin &gt;&gt; a &gt;&gt; b;          v.push_back({ b, a });      }      sort(v.begin(), v.end());      t = 0;      ans = 0;      for (int i = 0; i &lt; n; i++) {          if (v[i].second&gt;=t) {              ans++;              t = v[i].first;          }      }      cout &lt;&lt; ans &lt;&lt; endl;  }  return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string(字符串)</title>
      <link href="2021/02/08/string/"/>
      <url>2021/02/08/string/</url>
      
        <content type="html"><![CDATA[<h2 id="c-stl库中vector的基本用法"><a href="#c-stl库中vector的基本用法" class="headerlink" title="c++stl库中vector的基本用法"></a>c++stl库中vector的基本用法</h2><a id="more"></a><h2 id="string的常用方法"><a href="#string的常用方法" class="headerlink" title="string的常用方法"></a>string的常用方法</h2><ul><li>string支持赋值，比较，连接(+,+=)<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-C++"><code class="language-C++">s.length();     //字符串长度s.empty();      //判断是否为空，空返回1，不空返回0s.erase(s.begin()+i); //删除下标为i的字符s.substr(x, n); //返回从s的下标x开始的n个字符组成的字符串，如果n省略就取到底s.erase(x,n);   //删除从x开始的n个字符，n省略则删到底s.insert(p,s1,pos,len); //字符串中插入字符串，后两个参数截取s1，可省略,p为下标s.insert(p,n,c);    //在p处插入n个字符cs.replace(p0,len0,s1,len); //删除+字符串插入，后两个参数可省略s.find(item);   //查找（元素或者字符串），返回第一次出现的下标，可以指定位置s.find(item,pos);   //可以从指定位置开始查找s.refind();     //与find相似，从后往前查找，也可以指定位置</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iterator（迭代器）</title>
      <link href="2021/02/07/iterator/"/>
      <url>2021/02/07/iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="c-中iterator的基本用法"><a href="#c-中iterator的基本用法" class="headerlink" title="c++中iterator的基本用法"></a>c++中iterator的基本用法</h2><a id="more"></a><h2 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h2><pre class=" language-c++"><code class="language-c++">vector&lt;int&gt;::iterator it=v.begin();auto it=v.begin();   //两者是等价的</code></pre><ul><li>在这里it类似于一个指针，指向v的第一个元素；</li><li>it等价于&amp;v[0],*it等价于v[0];</li><li>it也可以进行加减操作，eg：it+3指向第四个元素；</li><li>it++后，it指向的就是v的第二个元素(v[1])了；</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue（队列）</title>
      <link href="2021/02/07/queue/"/>
      <url>2021/02/07/queue/</url>
      
        <content type="html"><![CDATA[<h2 id="c-中string的基本用法"><a href="#c-中string的基本用法" class="headerlink" title="c++中string的基本用法"></a>c++中string的基本用法</h2><a id="more"></a><h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue(队列)"></a>queue(队列)</h2><pre class=" language-c++"><code class="language-c++">queue&lt; type &gt; q;  //创建一个类型为type的队列qq.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出队q.front();      //获取队首元素q.empty();      //判断队列是否为空，空返回1，不空返回0</code></pre><h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue(优先队列)"></a>priority_queue(优先队列)</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p> priority_queue自带排序功能（两种）</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><pre class=" language-c++"><code class="language-c++">//默认为数值大在队首top（从大到小排）priority_queue&lt;char&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt;q; //等价//以下格式为数值小的在队首，即从小到大排priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</code></pre><pre class=" language-c++"><code class="language-c++">q.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出列q.top();        //获取队首元素，与queue的front一样q.empty();      //判断是否为空</code></pre>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map（映射）</title>
      <link href="2021/02/07/map/"/>
      <url>2021/02/07/map/</url>
      
        <content type="html"><![CDATA[<h2 id="c-中map的基本用法"><a href="#c-中map的基本用法" class="headerlink" title="c++中map的基本用法"></a>c++中map的基本用法</h2><a id="more"></a><h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><h3 id="建立方法："><a href="#建立方法：" class="headerlink" title="建立方法："></a>建立方法：</h3><pre class=" language-C++"><code class="language-C++">map&lt;key,value&gt; mp;unordered_map&lt;key,value&gt;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-c++"><code class="language-c++">map&lt;string, int&gt; mp;mp.insert({ "aaa", 1 });mp.insert({ "bbb", 2 });</code></pre><h3 id="遍历方法-迭代器-："><a href="#遍历方法-迭代器-：" class="headerlink" title="遍历方法(迭代器)："></a>遍历方法(迭代器)：</h3><pre class=" language-c++"><code class="language-c++">for (auto i:mp) {    cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl;}</code></pre><ul><li>按照key的值由小到大进行输出<pre class=" language-c++"><code class="language-c++">for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end();it++) {  cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;  //cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;//理解为指针}</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数:"></a>常用函数:</h3><pre class=" language-C++"><code class="language-C++">mp.size();  //获取元素个数mp.empty();  //判断是否为空mp.clear();  //清空mpmp.begin();  //返回mp中最小key的迭代器，和set一样，只可以用到--和++操作mp.end();   //返回mp最大key的迭代器的后一个迭代器mp.find(key);  //在mp中查找一个key并返回其迭代器，找不到则返回mp.end（）mp.count(key);  //在mp中查找key的数量，因为map中key唯一，所以只返回1或0mp.erase(key); //在mp中删除key所在的项mp[key];  //返回mp中key对应的value，若key不存在，则默认构造key的value类型的值为0mp[key] = value;  //构造值mp.lower_bound(item); //返回map中第一个key大于等于item的迭代器，找不到则返回会mp.end()mp.upper_bound(item); //返回map中第一个key大于item的迭代器，找不到则返回会mp.end()</code></pre><h3 id="unordered-map中的unordered"><a href="#unordered-map中的unordered" class="headerlink" title="unordered_map中的unordered"></a>unordered_map中的unordered</h3>set和map前都可以加上unordered使得内部的元素不敢排序顺序存储，底层原理实现为hash，可以使所有的查询，修改，删除操作都变成o(1)复杂度</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
