<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分</title>
      <link href="2021/03/08/binary-search/"/>
      <url>2021/03/08/binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="整数二分模板"><a href="#整数二分模板" class="headerlink" title="整数二分模板"></a>整数二分模板</h2><pre class=" language-c++"><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch(int l, int r){    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    }    return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch(int l, int r){    while (l &lt; r)    {        int mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}</code></pre><h2 id="浮点数二分模板"><a href="#浮点数二分模板" class="headerlink" title="浮点数二分模板"></a>浮点数二分模板</h2><pre class=" language-c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch(double l, double r){    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    {        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    return l;}</code></pre><h2 id="二分题（入门）"><a href="#二分题（入门）" class="headerlink" title="二分题（入门）"></a>二分题（入门）</h2><h3 id="整数二分例题（待补充）"><a href="#整数二分例题（待补充）" class="headerlink" title="整数二分例题（待补充）"></a>整数二分例题（待补充）</h3><p><a href="https://www.luogu.com.cn/problem/P1873">https://www.luogu.com.cn/problem/P1873</a></p><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int a[1000005];int n, m;bool check(int k){ // 检查可行性，k为锯片高度    long long sum = 0;    for (int i = 1; i &lt;= n; i++) // 检查每一棵树        if (a[i] &gt; k) // 如果树高于锯片高度            sum += (long long)(a[i] - k); // 累加树木长度    return sum &gt;= m; // 如果满足最少长度代表可行}int find(){    int l = 1, r = 1000000001; // 因为是左闭右开的，所以10亿要加1    while (l + 1 &lt; r) { // 如果两点不相邻        int mid = (l + r) / 2; // 取中间值        if (check(mid)) // 如果可行            l = mid; // 升高锯片高度        else            r = mid; // 否则降低锯片高度    }    return l; // 返回左边值}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    cout &lt;&lt; find();    return 0;}</code></pre><h3 id="浮点数二分例题（待补充）"><a href="#浮点数二分例题（待补充）" class="headerlink" title="浮点数二分例题（待补充）"></a>浮点数二分例题（待补充）</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2899">http://acm.hdu.edu.cn/showproblem.php?pid=2899</a></p><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define e 1e-7double fac(double a, double b){    return 6 * a * a * a * a * a * a * a + 8 * a * a * a * a * a * a + 7 * a * a * a + 5 * a * a - b * a;}double fac0(double a, double b){    return 42 * a * a * a * a * a * a + 48 * a * a * a * a * a + 21 * a * a + 10 * a - b;}int main(){    int t;    double n;    cin &gt;&gt; t;    while (t--) {        cin&gt;&gt;n;        double l = 0;        double r = 100;        while (r - l &gt; e) {            double mid = (l + r) / 2;            if (fac0(mid, n) &gt; 0)                r = mid;            else                l = mid;        }        printf("%.4lf\n", fac(r, n));    }    return 0;}</code></pre><h2 id="三分模板（待补充）"><a href="#三分模板（待补充）" class="headerlink" title="三分模板（待补充）"></a>三分模板（待补充）</h2><pre class=" language-c++"><code class="language-c++">lmid = left + (right - left &gt;&gt; 1);rmid = lmid + (right - lmid &gt;&gt; 1);  // 对右侧区间取半if (cal(lmid) &gt; cal(rmid))  right = rmid;else  left = lmid;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼编码长度简便求法</title>
      <link href="2021/03/07/hafumanbianmachengdu/"/>
      <url>2021/03/07/hafumanbianmachengdu/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫曼编码长度求法（使用Stl等）"><a href="#哈夫曼编码长度求法（使用Stl等）" class="headerlink" title="哈夫曼编码长度求法（使用Stl等）"></a>哈夫曼编码长度求法（使用Stl等）</h2><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1053">http://acm.hdu.edu.cn/showproblem.php?pid=1053</a></li></ul><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt; using namespace std;/*1.获取字符串2.map记录字符与其对应的出现的次数3.按照从小到大的顺序入列priority_queue（优先队列）4.每次出队两个，相加后再次入队，并进行排序5.用ans记录每一次相加和temp值之和，当队列中剩下一个元素时，ans的值即为所求*/string s;int main(){    int ans = 0;    map&lt;char, int&gt; mp;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //升序排列    getline(cin, s);    if (s == "END") {        break;    }    int len = s.length();    for (int i = 0; i &lt; len; i++) { //记录字符与其对应的出现的次数        if (mp.find(s[i]) == mp.end()) {            mp[s[i]] = 1;        } else {            mp[s[i]]++;        }    }    for (map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) {        q.push(it-&gt;second); //字符出现的次数入队    }    while (q.size() != 1) {        int a, b, temp; //a，b记录最小的两个次数        a = q.top();        q.pop();        b = q.top();        q.pop();        temp = a + b; //队列中最小的两个次数相加        ans += temp;        q.push(temp); //最小的两个次数相加再次入队，优先队列自行排序    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="2021/03/04/dp/"/>
      <url>2021/03/04/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">for (int i = 1; i &lt;= n; i++) {     for (int j = m; j &gt;= w[i]; j--) {         f[j] = max(f[j - w[i]] + v[i], f[j]);    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.luogu.com.cn/problem/P2871">https://www.luogu.com.cn/problem/P2871</a><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int w[3410], v[3410];int f[13000];int main(){  int m, n;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= n; i++) {      cin &gt;&gt; w[i] &gt;&gt; v[i];  }  for (int i = 1; i &lt;= n; i++) {      for (int j = m; j &gt;= w[i]; j--) {          f[j] = max(f[j - w[i]] + v[i], f[j]);      }  }  cout &lt;&lt; f[m] &lt;&lt; endl;  return 0;}</code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2></li><li>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">for (int i = 1; i &lt;= n; i++) {  for (int l = w[i]; l &lt;= W; l++) {      f[l] = max(f[l], f[l - w[i]] + v[i]);  }}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3></li><li><a href="https://www.luogu.com.cn/problem/P1616">https://www.luogu.com.cn/problem/P1616</a><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int maxn = 1e4 + 5;const int maxW = 1e7 + 5;int n, m, w[maxn], v[maxn];long long f[maxW];int main(){cin &gt;&gt; m &gt;&gt; n;for (int i = 1; i &lt;= n; i++) {    cin &gt;&gt; w[i] &gt;&gt; v[i];}for (int i = 1; i &lt;= n; i++) {    for (int l = w[i]; l &lt;= m; l++) {        f[l] = max(f[l], f[l - w[i]] + v[i]);    }}cout &lt;&lt; f[m];return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/03/03/bing-cha-ji/"/>
      <url>2021/03/03/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集基础核心代码"><a href="#并查集基础核心代码" class="headerlink" title="并查集基础核心代码"></a>并查集基础核心代码</h2><pre class=" language-c++"><code class="language-c++">int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = t2;    }}</code></pre><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">http://acm.hdu.edu.cn/showproblem.php?pid=1213</a></li></ul><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int p[1010];void init() { for (int i = 0; i &lt; 1010; i++) {        p[i] = i;    }}int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = t2;    }}int main(){    int t;    cin &gt;&gt; t;    int n, m, x, y, ans;    while (t--) {        cin &gt;&gt; n &gt;&gt; m;        init();        for (int i = 0; i &lt; m; i++) {            cin &gt;&gt; x &gt;&gt; y;            Union(x, y);        }        ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (p[i]==i) {                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="类似题型"><a href="#类似题型" class="headerlink" title="类似题型"></a>类似题型</h2><ul><li><a href="http://poj.org/problem?id=2524">http://poj.org/problem?id=2524</a></li><li><a href="http://poj.org/problem?id=1611">http://poj.org/problem?id=1611</a></li><li><a href="http://poj.org/problem?id=1703">http://poj.org/problem?id=1703</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论入门</title>
      <link href="2021/02/11/math/"/>
      <url>2021/02/11/math/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数–欧几里得算法"><a href="#最大公约数–欧几里得算法" class="headerlink" title="最大公约数–欧几里得算法"></a>最大公约数–欧几里得算法</h2><pre class=" language-C++"><code class="language-C++">int gcd(int a, int b){    return b == 0 ? a : gcd(b, a % b);}</code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><ul><li>gcd(a,b) * lcm(a,b) = a * b;<pre class=" language-C++"><code class="language-C++">int lcm(int a, int b){  return a * b / gcd(a, b);}</code></pre></li></ul><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow(long long a, long long b){    long long ret = 1;    while (b) {        if (b & 1) {            ret *= a;        }        a *= a;        b &gt;&gt;= 1;    }    return ret;}</code></pre><h2 id="快速幂取模-计算a-b-mod-m"><a href="#快速幂取模-计算a-b-mod-m" class="headerlink" title="快速幂取模:计算a^b mod m"></a>快速幂取模:计算a^b mod m</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow_mod(long long a, long long b, long long m){    long long res = 1;    while (b &gt; 0) {        if (b & 1)            res = res * a % m;        a = a * a % m;        b &gt;&gt;= 1;    }    return res;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector(动态数组)</title>
      <link href="2021/02/08/vector/"/>
      <url>2021/02/08/vector/</url>
      
        <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre class=" language-c++"><code class="language-c++">vector&lt;type&gt; v; //后面可以加{},()进行初始化vector&lt;double&gt; v2{1, 2, 3, 6, 5};vector&lt;long long&gt; v3(20);        //长度为20vector&lt;string&gt; v4(20, "abcde");  //长度为20</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-c++"><code class="language-c++">v.push_back(item);  //v后面添加元素itemv.pop_back();       //删除v的最后一个元素v.size();           //返回元素个数v.resize(n);        //把v的长度设为nv.empty();          //判断是否为空，空返回1，不空返回0v.clear();          //清空v中的元素v.front();          //返回首元素的引用v.back();           //返回尾元素的引用v.begin();          //返回首迭代器，指向第一个元素v.end();            //返回尾迭代器，指向最后一个元素的下一个位置   </code></pre><h2 id="vector中使用pair"><a href="#vector中使用pair" class="headerlink" title="vector中使用pair"></a>vector中使用pair</h2><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">http://acm.hdu.edu.cn/showproblem.php?pid=2037</a>（活动安排问题）</p><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){  int n, a, b;  int ans,t;  while (cin&gt;&gt;n && n) {      vector&lt;pair&lt;int, int&gt;&gt; v;      for (int i = 0; i &lt; n; i++) {          cin &gt;&gt; a &gt;&gt; b;          v.push_back({ b, a });      }      sort(v.begin(), v.end());      t = 0;      ans = 0;      for (int i = 0; i &lt; n; i++) {          if (v[i].second&gt;=t) {              ans++;              t = v[i].first;          }      }      cout &lt;&lt; ans &lt;&lt; endl;  }  return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string(字符串)</title>
      <link href="2021/02/08/string/"/>
      <url>2021/02/08/string/</url>
      
        <content type="html"><![CDATA[<h2 id="string的常用方法"><a href="#string的常用方法" class="headerlink" title="string的常用方法"></a>string的常用方法</h2><ul><li>string支持赋值，比较，连接(+,+=)<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-C++"><code class="language-C++">s.length();     //字符串长度s.empty();      //判断是否为空，空返回1，不空返回0s.erase(s.begin()+i); //删除下标为i的字符s.substr(x, n); //返回从s的下标x开始的n个字符组成的字符串，如果n省略就取到底s.erase(x,n);   //删除从x开始的n个字符，n省略则删到底s.insert(p,s1,pos,len); //字符串中插入字符串，后两个参数截取s1，可省略,p为下标s.insert(p,n,c);    //在p处插入n个字符cs.replace(p0,len0,s1,len); //删除+字符串插入，后两个参数可省略s.find(item);   //查找（元素或者字符串），返回第一次出现的下标，可以指定位置s.find(item,pos);   //可以从指定位置开始查找s.refind();     //与find相似，从后往前查找，也可以指定位置</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iterator（迭代器）</title>
      <link href="2021/02/07/iterator/"/>
      <url>2021/02/07/iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h2><pre class=" language-c++"><code class="language-c++">vector&lt;int&gt;::iterator it=v.begin();auto it=v.begin();   //两者是等价的</code></pre><ul><li>在这里it类似于一个指针，指向v的第一个元素；</li><li>it等价于&amp;v[0],*it等价于v[0];</li><li>it也可以进行加减操作，eg：it+3指向第四个元素；</li><li>it++后，it指向的就是v的第二个元素(v[1])了；</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue（队列）</title>
      <link href="2021/02/07/queue/"/>
      <url>2021/02/07/queue/</url>
      
        <content type="html"><![CDATA[<h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue(队列)"></a>queue(队列)</h2><pre class=" language-c++"><code class="language-c++">queue&lt; type &gt; q;  //创建一个类型为type的队列qq.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出队q.front();      //获取队首元素q.empty();      //判断队列是否为空，空返回1，不空返回0</code></pre><h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue(优先队列)"></a>priority_queue(优先队列)</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p> priority_queue自带排序功能（两种）</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><pre class=" language-c++"><code class="language-c++">//默认为数值大在队首top（从大到小排）priority_queue&lt;char&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt;q; //等价//以下格式为数值小的在队首，即从小到大排priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</code></pre><pre class=" language-c++"><code class="language-c++">q.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出列q.top();        //获取队首元素，与queue的front一样q.empty();      //判断是否为空</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map（映射）</title>
      <link href="2021/02/07/map/"/>
      <url>2021/02/07/map/</url>
      
        <content type="html"><![CDATA[<h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><h3 id="建立方法："><a href="#建立方法：" class="headerlink" title="建立方法："></a>建立方法：</h3><pre class=" language-C++"><code class="language-C++">map&lt;key,value&gt; mp;unordered_map&lt;key,value&gt;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-c++"><code class="language-c++">map&lt;string, int&gt; mp;mp.insert({ "aaa", 1 });mp.insert({ "bbb", 2 });</code></pre><h3 id="遍历方法-迭代器-："><a href="#遍历方法-迭代器-：" class="headerlink" title="遍历方法(迭代器)："></a>遍历方法(迭代器)：</h3><pre class=" language-c++"><code class="language-c++">for (auto i:mp) {    cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl;}</code></pre><ul><li>按照key的值由小到大进行输出<pre class=" language-c++"><code class="language-c++">for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end();it++) {  cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;  //cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;//理解为指针}</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数:"></a>常用函数:</h3><pre class=" language-C++"><code class="language-C++">mp.size();  //获取元素个数mp.empty();  //判断是否为空mp.clear();  //清空mpmp.begin();  //返回mp中最小key的迭代器，和set一样，只可以用到--和++操作mp.end();   //返回mp最大key的迭代器的后一个迭代器mp.find(key);  //在mp中查找一个key并返回其迭代器，找不到则返回mp.end（）mp.count(key);  //在mp中查找key的数量，因为map中key唯一，所以只返回1或0mp.erase(key); //在mp中删除key所在的项mp[key];  //返回mp中key对应的value，若key不存在，则默认构造key的value类型的值为0mp[key] = value;  //构造值mp.lower_bound(item); //返回map中第一个key大于等于item的迭代器，找不到则返回会mp.end()mp.upper_bound(item); //返回map中第一个key大于item的迭代器，找不到则返回会mp.end()</code></pre><h3 id="unordered-map中的unordered"><a href="#unordered-map中的unordered" class="headerlink" title="unordered_map中的unordered"></a>unordered_map中的unordered</h3>set和map前都可以加上unordered使得内部的元素不敢排序顺序存储，底层原理实现为hash，可以使所有的查询，修改，删除操作都变成o(1)复杂度</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
