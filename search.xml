<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="2021/03/04/dp/"/>
      <url>2021/03/04/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">for (int i = 1; i &lt;= n; i++) {     for (int j = m; j &gt;= w[i]; j--) {         f[j] = max(f[j - w[i]] + v[i], f[j]);    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.luogu.com.cn/problem/P2871">https://www.luogu.com.cn/problem/P2871</a><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int w[3410], v[3410];int f[13000];int main(){  int m, n;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= n; i++) {      cin &gt;&gt; w[i] &gt;&gt; v[i];  }  for (int i = 1; i &lt;= n; i++) {      for (int j = m; j &gt;= w[i]; j--) {          f[j] = max(f[j - w[i]] + v[i], f[j]);      }  }  cout &lt;&lt; f[m] &lt;&lt; endl;  return 0;}</code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2></li><li>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class=" language-c++"><code class="language-c++">for (int i = 1; i &lt;= n; i++) {  for (int l = w[i]; l &lt;= W; l++) {      f[l] = max(f[l], f[l - w[i]] + v[i]);  }}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3></li><li><a href="https://www.luogu.com.cn/problem/P1616">https://www.luogu.com.cn/problem/P1616</a><pre class=" language-c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int maxn = 1e4 + 5;const int maxW = 1e7 + 5;int n, W, w[maxn], v[maxn];long long f[maxW];int main(){  cin &gt;&gt; W &gt;&gt; n;  for (int i = 1; i &lt;= n; i++) {      cin &gt;&gt; w[i] &gt;&gt; v[i];  }  for (int i = 1; i &lt;= n; i++) {      for (int l = w[i]; l &lt;= W; l++) {          f[l] = max(f[l], f[l - w[i]] + v[i]);      }  }  cout &lt;&lt; f[W];  return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/03/03/bing-cha-ji/"/>
      <url>2021/03/03/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集基础核心代码"><a href="#并查集基础核心代码" class="headerlink" title="并查集基础核心代码"></a>并查集基础核心代码</h2><pre class=" language-c++"><code class="language-c++">int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = p[t2];    }}</code></pre><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">http://acm.hdu.edu.cn/showproblem.php?pid=1213</a></li></ul><pre class=" language-c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int p[1010];void init() { for (int i = 0; i &lt; 1010; i++) {        p[i] = i;    }}int find(int x){    return x == p[x] ? x : find(p[x]);}void Union(int a, int b){    int t1 = find(a);    int t2 = find(b);    if (t1!=t2) {        p[t1] = p[t2];    }}int main(){    int t;    cin &gt;&gt; t;    int n, m, x, y, ans;    while (t--) {        cin &gt;&gt; n &gt;&gt; m;        init();        for (int i = 0; i &lt; m; i++) {            cin &gt;&gt; x &gt;&gt; y;            Union(x, y);        }        ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (p[i]==i) {                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="类似题型"><a href="#类似题型" class="headerlink" title="类似题型"></a>类似题型</h2><ul><li><a href="http://poj.org/problem?id=2524">http://poj.org/problem?id=2524</a></li><li><a href="http://poj.org/problem?id=1611">http://poj.org/problem?id=1611</a></li><li><a href="http://poj.org/problem?id=1703">http://poj.org/problem?id=1703</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数论入门</title>
      <link href="2021/02/11/math/"/>
      <url>2021/02/11/math/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数–欧几里得算法"><a href="#最大公约数–欧几里得算法" class="headerlink" title="最大公约数–欧几里得算法"></a>最大公约数–欧几里得算法</h2><pre class=" language-C++"><code class="language-C++">int gcd(int a, int b){    return b == 0 ? a : gcd(b, a % b);}</code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><ul><li>gcd(a,b) * lcm(a,b) = a * b;<pre class=" language-C++"><code class="language-C++">int lcm(int a, int b){  return a * b / gcd(a, b);}</code></pre></li></ul><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow(long long a, long long b){    long long ret = 1;    while (b) {        if (b & 1) {            ret *= a;        }        a *= a;        b &gt;&gt;= 1;    }    return ret;}</code></pre><h2 id="快速幂取模-计算a-b-mod-m"><a href="#快速幂取模-计算a-b-mod-m" class="headerlink" title="快速幂取模:计算a^b mod m"></a>快速幂取模:计算a^b mod m</h2><pre class=" language-c++"><code class="language-c++">long long quick_pow_mod(long long a, long long b, long long m){    long long res = 1;    while (b &gt; 0) {        if (b & 1)            res = res * a % m;        a = a * a % m;        b &gt;&gt;= 1;    }    return res;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vector(动态数组)</title>
      <link href="2021/02/08/vector/"/>
      <url>2021/02/08/vector/</url>
      
        <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre class=" language-c++"><code class="language-c++">vector&lt;type&gt; v; //后面可以加{},()进行初始化vector&lt;double&gt; v2{1, 2, 3, 6, 5};vector&lt;long long&gt; v3(20);        //长度为20vector&lt;string&gt; v4(20, "abcde");  //长度为20</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-c++"><code class="language-c++">v.push_back(item);  //v后面添加元素itemv.pop_back();       //删除v的最后一个元素v.size();           //返回元素个数v.resize(n);        //把v的长度设为nv.empty();          //判断是否为空，空返回1，不空返回0v.clear();          //清空v中的元素v.front();          //返回首元素的引用v.back();           //返回尾元素的引用v.begin();          //返回首迭代器，指向第一个元素v.end();            //返回尾迭代器，指向最后一个元素的下一个位置      </code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>string(字符串)</title>
      <link href="2021/02/08/string/"/>
      <url>2021/02/08/string/</url>
      
        <content type="html"><![CDATA[<h2 id="string的常用方法"><a href="#string的常用方法" class="headerlink" title="string的常用方法"></a>string的常用方法</h2><ul><li>string支持赋值，比较，连接(+,+=)<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class=" language-C++"><code class="language-C++">s.length();     //字符串长度s.empty();      //判断是否为空，空返回1，不空返回0s.erase(s.begin()+i); //删除下标为i的字符s.substr(x, n); //返回从s的下标x开始的n个字符组成的字符串，如果n省略就取到底s.erase(x,n);   //删除从x开始的n个字符，n省略则删到底s.insert(p,s1,pos,len); //字符串中插入字符串，后两个参数截取s1，可省略,p为下标s.insert(p,n,c);    //在p处插入n个字符cs.replace(p0,len0,s1,len); //删除+字符串插入，后两个参数可省略s.find(item);   //查找（元素或者字符串），返回第一次出现的下标，可以指定位置s.find(item,pos);   //可以从指定位置开始查找s.refind();     //与find相似，从后往前查找，也可以指定位置</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iterator（迭代器）</title>
      <link href="2021/02/07/iterator/"/>
      <url>2021/02/07/iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h2><pre class=" language-c++"><code class="language-c++">vector&lt;int&gt;::iterator it=v.begin();auto it=v.begin();   //两者是等价的</code></pre><ul><li>在这里it类似于一个指针，指向v的第一个元素；</li><li>it等价于&amp;v[0],*it等价于v[0];</li><li>it也可以进行加减操作，eg：it+3指向第四个元素；</li><li>it++后，it指向的就是v的第二个元素(v[1])了；</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>queue（队列）</title>
      <link href="2021/02/07/queue/"/>
      <url>2021/02/07/queue/</url>
      
        <content type="html"><![CDATA[<h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue(队列)"></a>queue(队列)</h2><pre class=" language-c++"><code class="language-c++">queue&lt; type &gt; q;  //创建一个类型为type的队列qq.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出队q.front();      //获取队首元素q.empty();      //判断队列是否为空，空返回1，不空返回0</code></pre><h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue(优先队列)"></a>priority_queue(优先队列)</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p> priority_queue自带排序功能（两种）</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><pre class=" language-c++"><code class="language-c++">//默认为数值大在队首top（从大到小排）priority_queue&lt;char&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt;q; //等价//以下格式为数值小的在队首，即从小到大排priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</code></pre><pre class=" language-c++"><code class="language-c++">q.push(item);   //在队尾添加元素itemq.size();       //队列长度q.pop();        //队首出列q.top();        //获取队首元素，与queue的front一样q.empty();      //判断是否为空</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>map（映射）</title>
      <link href="2021/02/07/map/"/>
      <url>2021/02/07/map/</url>
      
        <content type="html"><![CDATA[<h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><h3 id="建立方法："><a href="#建立方法：" class="headerlink" title="建立方法："></a>建立方法：</h3><pre class=" language-C++"><code class="language-C++">map&lt;key,value&gt; mp;unordered_map&lt;key,value&gt;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-c++"><code class="language-c++">map&lt;string, int&gt; mp;mp.insert({ "aaa", 1 });mp.insert({ "bbb", 2 });</code></pre><h3 id="遍历方法-迭代器-："><a href="#遍历方法-迭代器-：" class="headerlink" title="遍历方法(迭代器)："></a>遍历方法(迭代器)：</h3><pre class=" language-c++"><code class="language-c++">for (auto i:mp) {    cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl;}</code></pre><ul><li>按照key的值由小到大进行输出<pre class=" language-c++"><code class="language-c++">for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end();it++) {  cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;  //cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;//理解为指针}</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数:"></a>常用函数:</h3><pre class=" language-C++"><code class="language-C++">mp.size();  //获取元素个数mp.empty();  //判断是否为空mp.clear();  //清空mpmp.begin();  //返回mp中最小key的迭代器，和set一样，只可以用到--和++操作mp.end();   //返回mp最大key的迭代器的后一个迭代器mp.find(key);  //在mp中查找一个key并返回其迭代器，找不到则返回mp.end（）mp.count(key);  //在mp中查找key的数量，因为map中key唯一，所以只返回1或0mp.erase(key); //在mp中删除key所在的项mp[key];  //返回mp中key对应的value，若key不存在，则默认构造key的value类型的值为0mp[key] = value;  //构造值mp.lower_bound(item); //返回map中第一个key大于等于item的迭代器，找不到则返回会mp.end()mp.upper_bound(item); //返回map中第一个key大于item的迭代器，找不到则返回会mp.end()</code></pre><h3 id="unordered-map中的unordered"><a href="#unordered-map中的unordered" class="headerlink" title="unordered_map中的unordered"></a>unordered_map中的unordered</h3>set和map前都可以加上unordered使得内部的元素不敢排序顺序存储，底层原理实现为hash，可以使所有的查询，修改，删除操作都变成o(1)复杂度</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
